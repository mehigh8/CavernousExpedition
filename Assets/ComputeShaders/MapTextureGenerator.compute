#pragma kernel CSMain
#include "Noise.compute"

struct Sphere
{
    float radius;
    float3 worldPosition;
};

struct Cylinder
{
    float radius;
    float3 basePosition;
    float3 topPosition;
    int sphereCount;
};


RWStructuredBuffer<Sphere> spheres;
int sphereListSize;
RWStructuredBuffer<Cylinder> cylinders;
int cylinderListSize;

float worldSize;

float noiseSeed;
float noiseScale;
float noiseHeight;
int noiseLayers;
float noiseLacunarity;
float noisePersistance;

RWTexture3D<float> mapTexture;
int textureSize;

float calculateNoise(float3 position)
{
    float noise = 0;
    float frequency = noiseScale / 100;
    float amplitude = 1;

    for (int i = 0; i < noiseLayers; i++)
    {
        float n = 1 - abs(snoise((float3(noiseSeed, noiseSeed, noiseSeed) + position) * frequency) * 2 - 1);
        noise += n * amplitude;

        amplitude *= noisePersistance;
        frequency *= noiseLacunarity;
    }

    return noise;
}

[numthreads(8,8,8)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= textureSize || id.y >= textureSize || id.z >= textureSize)
        return;
    
    float3 voxelWorldPos = (id / float(textureSize) - 0.5) * worldSize;
    float textureValue = -float(textureSize * textureSize * textureSize);
    
    for (int i = 0; i < sphereListSize; i++)
    {
        Sphere currentSphere = spheres[i];
        textureValue = max(textureValue, currentSphere.radius - distance(voxelWorldPos, currentSphere.worldPosition));
    }
    
    for (int i = 0; i < cylinderListSize; i++)
    {
        Cylinder currentCylinder = cylinders[i];
        float3 incrementVector = (currentCylinder.topPosition - currentCylinder.basePosition) / float(currentCylinder.sphereCount);
        
        for (int j = 0; j < currentCylinder.sphereCount; j++)
            textureValue = max(textureValue, currentCylinder.radius - distance(voxelWorldPos, currentCylinder.basePosition + incrementVector * j));
    }
    
    float noise = calculateNoise(voxelWorldPos) * noiseHeight;
    textureValue += noise;

    mapTexture[id] = textureValue;
}
